# -*- coding: utf-8 -*-
"""random_forest_cfb.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1iwW-FyZXdZrtmCOBxKu_lXOMYMk4CXRp
"""

import zipfile
from google.colab import drive

drive.mount('/content/drive/')

zip_ref = zipfile.ZipFile("/content/consumer_complaints.csv.zip", 'r')
zip_ref.extractall()
zip_ref.close()

import pandas as pd
import matplotlib.pyplot as plt
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import LabelEncoder
from sklearn.ensemble import RandomForestClassifier
from sklearn.metrics import accuracy_score, confusion_matrix
from sklearn.feature_extraction.text import TfidfVectorizer
import seaborn as sns

df = pd.read_csv("/content/consumer_complaints.csv")

df.head()

df = df[['product', 'consumer_complaint_narrative']]
df = df[pd.notnull(df['consumer_complaint_narrative'])]
df.head()

df['category_id']=df['product'].factorize()[0]
df.head()

X_train, X_test, y_train, y_test = train_test_split(df['consumer_complaint_narrative'], df['product'])

lb = LabelEncoder()
y_train = lb.fit_transform(y_train)
y_test = lb.fit_transform(y_test)

tfidf = TfidfVectorizer(analyzer='word', token_pattern=r'\w{1,}', max_features=5000)
tfidf.fit(df['consumer_complaint_narrative'])
X_train_tfidf = tfidf.transform(X_train)
X_test_tfidf = tfidf.transform(X_test)

clf = RandomForestClassifier(n_estimators=100, random_state=0)

clf.fit(X_train_tfidf, y_train)

y_pred = clf.predict(X_test_tfidf)

print(accuracy_score(y_test, y_pred))
confmat = confusion_matrix(y_test, y_pred)

category_id_df = df[['product', 'category_id']].drop_duplicates().sort_values('category_id')
category_to_id = dict(category_id_df.values)
id_to_category = dict(category_id_df[['category_id','product']].values)

fig, ax = plt.subplots(figsize=(16,10))
sns.heatmap(confmat, annot=True, fmt='d', cmap="BuPu", xticklabels=category_id_df[['product']].values, yticklabels=category_id_df[['product']].values)
plt.title('Consumer Finance Complaints')
plt.ylabel('Actual')
plt.xlabel('Predicted')
plt.show()